<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/30/hello-world/"/>
      <url>/2018/11/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>单例模式(Singleton Pattern)</title>
      <link href="/2018/05/21/2018-05-21-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/05/21/2018-05-21-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>定义：确保某一个类有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式是一种对象创建型模式。</p><p>单例模式的意图是为了确保一个类有且仅有一个实例，并为它提供一个全局访问点。</p></blockquote><h4 id="三个要点"><a href="#三个要点" class="headerlink" title="三个要点"></a>三个要点</h4><ul><li>单例类只能有一个实例</li><li>单例类必须自己创建自己的唯一实例</li><li>单例类必须给所有其他对象提供这一实例</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>减少内存开支</li><li>减少系统的性能开销</li><li>避免资源的多重占用</li><li>优化和共享资源访问</li><li>允许可变数目的实例</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>没有接口，扩展困难</li><li>单例没有完成，无法进行测试</li><li>职责过重，一定程度上违背了单一职责原则。因为既充当了工厂角色，提供了工厂方法，又充当了产品角色，包含业务方法，将产品的创建和产品的本身的功能融合到一起</li><li>自动垃圾回收机制对共享对象的回收，导致对象状态的丢失，&lt;Java1.2,可以使用注册表解决</li></ul><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul><li>生成唯一序列号的环境</li><li>共享访问点或共享数据</li><li>创建一个对象需要消耗的资源过多，例如：访问IO或数据库等资源</li><li>需要定义大量的静态常量和静态方法的环境，可以采用单例模式</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>多线程并发问题</li><li>对象复制，Java中默认不可以复制，若实现了Cloneable-&gt;clone方法，可以直接通过对象复制方式创建一个新对象，对象复制是不用调用类的构造函数，即使是私有的构造。单例不要实现Cloneable接口</li><li>多个类加载器会生成多个单例类，自行指定类加载器，并指定同一个类加载器。</li></ul><h4 id="单例类使用方式"><a href="#单例类使用方式" class="headerlink" title="单例类使用方式"></a>单例类使用方式</h4><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton INSTANCE <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="饿汉式-Lazy-Load"><a href="#饿汉式-Lazy-Load" class="headerlink" title="饿汉式(Lazy Load)"></a>饿汉式(Lazy Load)</h5><p>由于在定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象。</p><p>JVM加载类的6个步骤？</p><p>加载，初始化，</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>线程调度？</p><p>解决方法：</p><blockquote><p>在getInstance方法前加synchronized关键字，或者在方法加synchronized来实现</p></blockquote><h5 id="双检锁-双重校验锁"><a href="#双检锁-双重校验锁" class="headerlink" title="双检锁/双重校验锁"></a>双检锁/双重校验锁</h5><p>（DCL，即 double-checked locking）</p><p>关键字volatile讲解？</p><p>Synchronized：互斥性和可见性</p><p>volatile：可见性</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton INSTANCE <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一重判断</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//锁定代码块</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//第二重判断</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>静态成员变量增加修饰符volatile，可以确保多个线程都能正确处理，jdk1.5+。由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因为即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。</p><h5 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h5><p>IoDH：Initialization Demand Holder(初始化需求持有者)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">HolderClass</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> HolderClass<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>由于静态单 例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次 调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量 instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员 变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为 一种最好的Java语言单例模式实现方式(其缺点是与编程语言本身的特性相关，很多面向对象 语言不支持IoDH)。</p><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p> Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 不能通过 reflection attack 来调用私有构造方法。</p><pre class=" language-Java"><code class="language-Java">public enum Singleton {      INSTANCE;      public void see() {      }  } </code></pre><h4 id="饿汉式与懒汉式的对比"><a href="#饿汉式与懒汉式的对比" class="headerlink" title="饿汉式与懒汉式的对比"></a>饿汉式与懒汉式的对比</h4><p>饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性;从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉单例，而且在系统<br>加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。</p><p>懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</p><p>饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存;懒汉式单例类线程安全控 制烦琐，而且性能受影响。</p><h4 id="经验总结："><a href="#经验总结：" class="headerlink" title="经验总结："></a>经验总结：</h4><p>不建议使用无同步或同步方法的方式，建议使用饿汉式方式，只有在要明确实现 lazy loading 效果时，才会使用IoDH方式。如涉及到反序列化创建对象时，可以尝试使用枚举的方式，如有其他特殊的要求，可使用双重锁机制方式。</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Single </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
